# Работа с процессами в Linux

Процессы и потоки порождаются одинаково  
На уровни ядра потоки - это те же самые процессы, для них нет никакой дополнительной абстракции  
Разница лишь в том, что у потока ссылка на heap имеет тот же адрес, что и у родительского процесса  
Таким образом, они шарят адресное пространство и имеют общий доступ к нему и к исполняемому коду  
А вот стэк и регистры у них свои и при копировании клонируются  
Создается поток на низком уровне через вызов функции clone со спец флагами  

При создании же процесса через метод fork происходит клонирование всей информации, а вот heap клонируется по принципу copy_on_write  
Для запуска другой программы нужно использовать последовательность fork() => exec()  
Первая склонирует процесс, вторая - заменит все его содержимое на новую запускаемую программу  

Для хранения информации о процессах существуют две спец структуры данных: task_struct и thread_info  


### Системный планировщик (process sheduler)  
В linux процессы активно использующие ввод-вывод имеют более высокий приоритет перед вычислительными процессами  
Параметр nice работает довольно странно  nice : [-20; 19]  
Чем больше nice, тем меньше приоритет у процесса  
В Linux используется CFS(completely fair shceduler)  модель планировщика  
Очередь процессов реализуется через красно-черное дерево  

### Системные функции
При вызове системной функции параметры вызова загружаются в регистры общего назначения  
Результат работы системной функции также возвращается через регистр  
Вызов системной функции подразумевает переключение в режим ядра  
Это переключение в linux стоит очень дешево  
в момент вызова системной функции ядро получает контект процесса, который ее вызвал  
Этот контекст хранится у ядра в переменной current  

### Структуры данных ядра
 - списки  
 - очереди  
 - Map  
 - двоичные деревья  

### Системные прерывания
Разделены на две части: top и bottom  
Поступление данных от сетевой карты реализовано через прерывания  
Есть специальный флаг, который позволяет указать, что прерывания от устройства нужно использовать для вклада в пул энтропии ядра для генерации случайных чисел  
Исклюительные ситуации обрабатываются также, как прерывания  
Отличие лишь в том, что исключительные ситуации по своей природе синхронны, а прерывания - асинхронны  
Драйвер каждого устройства должен зарегистрироваться и получить свой IRQ.  
IRQ могут использоваться совместно  

### Общие сведения о синхронизации процессов
Избежать гонки ресурсов между потоками можно с помощью:  
 - неделимых (atomic) инструкций  
 - блокировок (lock)  

### Средства синхронизации ядра
В linux семафоры - это блокировки, которые переводят процесс в режим ожидания  
Как только ресурс освободится, ядро достанет процесс-прендтент, запустит его и отдаст ему ресурс  
У семафоров есть счетчик, который задает количество процессов, которые могут удержимвать ресурс  
Если счетчик равен 1, то такой семафор будет называться мьютексом  
Также мьютекс существует отдельно как отдельная сущность и доступен для блокировок  
В большинстве случаев предпочтительнее использование семафоров  

### Таймеры и управление временем
### Управление памятью
Процесс выделяет память внутри страниц. Страницы выдаются процессу ядром  
На самом деле, память выделяется не внутри страниц, а на физической памяти, страницы же существуют как отдельный список,
в котором хранятся адреса физической памяти. По сути, изначально вся память разбита на страницы и по требованию страницы отдаются процессам  
При вызове операции выделения памяти можно передавать модификторы:  
 - срочно, я обрабатывю прерывание  
 - выделить память, а я пошел в режим ожидания  
 - ...  

malloc - выделяет смежные страницы физической памяти  
kmalloc - выделяет смежные страницы и физической памяти, и виртуальной памяти  
vmalloc - выделяет смежные страницы виртуальной памяти  

У процессов ядра меньший размер стэка
