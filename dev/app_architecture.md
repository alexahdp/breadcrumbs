# Архитектура приложений

Главная проблема в разработке ПО - борьба со сложностью.


## Типовые архитектуры приложений

### Трехслойная архитектура
 * представление/клиент
  - обладает простыми функциями, можешь заниматься простой валидацией, взаимодействие с пользователем, подготовка данных в соответствующий для пользователя формат  
 * бизнес-логика  
  - на этом слое сосредоточена основная логика работы приложения, обработка данных. Слой бизнес-логики не должен зависеть от слоя представления  
 * слой данных  
  - обеспечение хранения и доступа к данным  


### Луковичная архитектура
Основные принципы:
 - слои могут зависеть от внутренних, но не могут от внешних  
 - доменная модель всегда находится в центре архитектуры  
 - на внешнем слое располагаются: UI, инфраструктура, тесты  
 - инверсия зависимостей является ключевой особенностью данной архитектуры  
 - слой данных располагается не в центре, а вынесен в инфраструктуру  


### Гексагональная архитектура
Является логичным продолжением луковичной архитектуры и разделяет ui, инфраструктуру и данные.
Все эти сущности являются внешними по отношению к слою бизнес-логики и их можно разделить на порты и адаптеры.

![Гексагональная архитектура](https://hsto.org/webt/wp/gk/2w/wpgk2wxy5fgyjtrwuzctapvv19y.png)

В ходе своего развития приложения имеют свойство вырастать до значительных размеров. Они аккумулируют в себе большее количество бизнес-логики и сущностей и, в итоге, превращаются в то, что мы называем **монолитом**. Монолитом они становятся потому, что теперь бизнес-логика и/или слой данных стали слишком большими и сильносвязными и любые правки становятся слишком сложными и дорогостоящими. Еще одна проблема монолитов - масштабирование. Монолитные приложения масштабируются целиком, что является довольно дорогостоящей задачей, а иногда и вовсе невыполнимой. Отсюда появился новый виток в разработке ПО - микросервисы.

Микроросервисы - это небольшие независимые приложения, каждое из которых выполняет свою роль и имеет четкую зону ответственности. Каждый микросервис может иметь свой собственный технологический стэк, жизненный цикл разработки и релизов (в идеальном мире).

Основные характеристики микросервисов:
 - Разделение на компоненты (сервисы)  
 - Группировка по бизнес-задачам  
 - Сервисы имеют бизнес-смысл  
 - Умные сервисы и простые коммуникации  
 - Децентрализованное управление  
 - Децентрализованное управление данными  
 - Автоматизация развертывания и мониторинга  
 - Design for failure (Chaos Monkey)  

На последнем пункте следует остановиться отдельно. Поскольку теперь у нас не один большой сервис, а множество мелких, да еще и нагрузка сильно выросла, мы должны быть готовы к тому, что любой из наших микросервисов может умереть в любой момент и этого никто не должен заметить.
Каждый запущенный микросервис требует наличия мониторингов, сбора логов и всего спектра инфраструктурной работы. Проделывать все это вручную практически невозможно. Как результат - новый виток и появление облачных сервисов наподобие Kubernetes.

Kubernetes - облачная платформа, которая позволяет упростить процесс работы с микросервисами.
В свою очередь, приложения, разрабатываемые для подобной облачной платформы должны удовлетворять ряду инфраструктурных требований. Эти требования хорошо сформулированы в манифесте [12-factors-apps](https://12factor.net/ru/). 

Однако, помимо инфраструктурных требований, в микросервисной архитектуре возникают требования и к разделению бизнес-логики, обработке данных и способе взаимодействия с другими микросервисами.

И пока мы не углубились слишком далеко в микросервисную архитектуру, хотелось бы еще раз вернуться к монолиту, сравнить его с микросервисной архитектурой и привести некоторые аргументы в сторону обеих технологий.

Монолит лучше выбирать в следующих случаях:
 - Если у вас новый домен и/или нет знаний в этом домене
 - Если вы делаете прототип или быстрое решение
 - Если команда не очень квалифицированная (все начинающие, например)
 - Если вам требуется просто написать код и забыть о нем
 - Если мало денег на проект — микросервисы обойдутся дорого

Микросервисы лучше выбрать, если:
 - Точно понадобится линейное масштабирование
 - Вы понимаете бизнес-домен, сможете выделить ограниченный контекст и сможете обеспечить согласованность на бизнес-уровне
 - Команда высококвалифицированная, есть опыт и пара загубленных проектов с микросервисами в прошлом (все равно с первого раза сделать микросервисы не выходит)
 - Предстоит долгосрочное сотрудничество с заказчиком
 - Достаточно средств для инвестирования в инфраструктуру


## Принципы разделения приложения на микросервисы
 * если необходимо, чтобы две микрослужбы активно взаимодействовали друг с другом, то, скорее всего, они должны быть одной микрослужбой.
 * если микрослужба должна полагаться на другую службу для обслуживания прямого запроса, то она не является полностью автономной.
 * некоторые говорят, что слабая модель предметной области является антишаблоном. 
В действительности это зависит от того, что вы реализуете. Если вы создаете довольно простую микрослужбу  (например, службу CRUD), то слабая модель предметной области не является антишаблоном. Однако если вам предстоит иметь дело со сложной предметной областью микрослужбы, имеющей множество постоянно меняющихся бизнес-правил, слабая модель предметной области может быть антишаблоном для этой микрослужбы или ограниченного контекста.  В этом случае проектирование в соответствии с расширенной моделью предметной области с сущностями,  содержащими данные и поведение, а также с реализацией дополнительных шаблонов DDD (агрегатов, объектов значений и т. п.) может обеспечить огромные преимущества для долгосрочного успешного существования такой микрослужбы.
