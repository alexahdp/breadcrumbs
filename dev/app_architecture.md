# Архитектура приложений

Главная проблема в разработке ПО - борьба со сложностью.


## Типовые архитектуры приложений

### MVC
Этому архитектурному паттерну уже довольно много лет (он был впервые предложен еще в 1979 году). Суть его очень проста: разделение зон ответственности на три типа:
 - **model** - инкапсулирует в себе бизнес-логику, взаимодействие с хранилищем данных, валидацию данных    
 - **view** - ответственен за представление данных (в случае веб-приложений - рендеринг html-страниц)  
 - **controller** - отвечает за общение с реальным миром (в случае веб-приложений - прием запросов, отправка ответов, взаимодействие с транспортным протоколом)  
Важные особенности:
 - каждая view принадлежит только одному контроллеру  
 - у одного контроллера может быть множество view  
 - контроллер обращается к модели для получения данных, после чего передает эти данные view для формирования ответа пользователю  

Проблемные места:
 - MVC-паттерн довольно просто, но в то же время, недостаточно гибок. Скажем, в нем не предусмотрено переиспользование представлений или логики моделей, хотя и можно выносить отдельный код в общие библиотеки. Это послужило предпосылкой создания другого паттерна - HMVC  
 - в этом паттерне очень тяжело организовать взаимодействие между view и model, что является очень необходимым, например, во фронтенде, где view может генерировать действия для изменения модели, а изменение модели, в свою очередь, должно приводить к изменению view  

### HMVC
Hierarchical-model-view-controller. Суть данного паттерна в том, чтобы организовать триплеты MVC в переиспользуемые группы. Это позволяет лучше следовать принципу DRY, но по-прежнему не решает проблемы взаимодействия view и model.  

### MVP - Model-vew-presenter
Этот паттерн получил широкое распространение во фронтенд-разработке, где view способен генерировать действия, эти действия уходят в presenter, он, в свою очередь, на основании действия решает как должны измениться данные и представление. Таким образом, view и model оказываются изолированными друг от друга. 

### MVVM model-view-viewModel
 - один viewModel связан только с одним view  
 - логика, которая могла бы оказаться во view должна быть размещена в viewModel  
 - связывание данных viewModel с данными, попадающими во view (концепция двустороннего data-binding)  

### Model-view-presenter-viewModel
> TODO

### Трехслойная архитектура
 * представление/клиент
  - обладает простыми функциями, можешь заниматься простой валидацией, взаимодействие с пользователем, подготовка данных в соответствующий для пользователя формат  
 * бизнес-логика  
  - на этом слое сосредоточена основная логика работы приложения, обработка данных. Слой бизнес-логики не должен зависеть от слоя представления  
 * слой данных  
  - обеспечение хранения и доступа к данным  

![Трехслойная архитектура](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/CSD_SCHEME.png/1920px-CSD_SCHEME.png)

### Луковичная архитектура
Основные принципы:
 - слои могут зависеть от внутренних, но не могут от внешних  
 - доменная модель всегда находится в центре архитектуры  
 - на внешнем слое располагаются: UI, инфраструктура, тесты  
 - инверсия зависимостей является ключевой особенностью данной архитектуры  
 - слой данных располагается не в центре, а вынесен в инфраструктуру  

![onion architecture](https://www.codeguru.com/imagesvr_ce/2236/Onion1.png)

### Гексагональная архитектура
Является логичным продолжением луковичной архитектуры и разделяет ui, инфраструктуру и данные.
Все эти сущности являются внешними по отношению к слою бизнес-логики и их можно разделить на порты и адаптеры.

![Гексагональная архитектура](https://hsto.org/webt/wp/gk/2w/wpgk2wxy5fgyjtrwuzctapvv19y.png)

В ходе своего развития приложения имеют свойство вырастать до значительных размеров. Они аккумулируют в себе большее количество бизнес-логики и сущностей и, в итоге, превращаются в то, что мы называем **монолитом**. Монолитом они становятся потому, что теперь бизнес-логика и/или слой данных стали слишком большими и сильносвязными и любые правки становятся слишком сложными и дорогостоящими. Еще одна проблема монолитов - масштабирование. Монолитные приложения масштабируются целиком, что является довольно дорогостоящей задачей, а иногда и вовсе невыполнимой. Отсюда появился новый виток в разработке ПО - микросервисы.

Микроросервисы - это небольшие независимые приложения, каждое из которых выполняет свою роль и имеет четкую зону ответственности. Каждый микросервис может иметь свой собственный технологический стэк, жизненный цикл разработки и релизов (в идеальном мире).

![Микросервисная архитектура](https://habrastorage.org/files/cad/d35/87f/cadd3587f56b4cc38bb8cbcc2e743c09.png)

Основные характеристики микросервисов:
 - Разделение на компоненты (сервисы)  
 - Группировка по бизнес-задачам  
 - Сервисы имеют бизнес-смысл  
 - Умные сервисы и простые коммуникации  
 - Децентрализованное управление  
 - Децентрализованное управление данными  
 - Автоматизация развертывания и мониторинга  
 - Design for failure (Chaos Monkey)  

На последнем пункте следует остановиться отдельно. Поскольку теперь у нас не один большой сервис, а множество мелких, да еще и нагрузка сильно выросла, мы должны быть готовы к тому, что любой из наших микросервисов может умереть в любой момент и этого никто не должен заметить.
Каждый запущенный микросервис требует наличия мониторингов, сбора логов и всего спектра инфраструктурной работы. Проделывать все это вручную практически невозможно. Как результат - новый виток и появление облачных сервисов наподобие Kubernetes.

Kubernetes - облачная платформа, которая позволяет упростить процесс работы с микросервисами.
В свою очередь, приложения, разрабатываемые для подобной облачной платформы должны удовлетворять ряду инфраструктурных требований. Эти требования хорошо сформулированы в манифесте [12-factors-apps](https://12factor.net/ru/). 

Однако, помимо инфраструктурных требований, в микросервисной архитектуре возникают требования и к разделению бизнес-логики, обработке данных и способе взаимодействия с другими микросервисами.

И пока мы не углубились слишком далеко в микросервисную архитектуру, хотелось бы еще раз вернуться к монолиту, сравнить его с микросервисной архитектурой и привести некоторые аргументы в сторону обеих технологий.

Монолит лучше выбирать в следующих случаях:
 - Если у вас новый домен и/или нет знаний в этом домене
 - Если вы делаете прототип или быстрое решение
 - Если команда не очень квалифицированная (все начинающие, например)
 - Если вам требуется просто написать код и забыть о нем
 - Если мало денег на проект — микросервисы обойдутся дорого

Микросервисы лучше выбрать, если:
 - Точно понадобится линейное масштабирование
 - Вы понимаете бизнес-домен, сможете выделить ограниченный контекст и сможете обеспечить согласованность на бизнес-уровне
 - Команда высококвалифицированная, есть опыт и пара загубленных проектов с микросервисами в прошлом (все равно с первого раза сделать микросервисы не выходит)
 - Предстоит долгосрочное сотрудничество с заказчиком
 - Достаточно средств для инвестирования в инфраструктуру


## Принципы разделения приложения на микросервисы
 * если необходимо, чтобы две микрослужбы активно взаимодействовали друг с другом, то, скорее всего, они должны быть одной микрослужбой.
 * если микрослужба должна полагаться на другую службу для обслуживания прямого запроса, то она не является полностью автономной.
 * некоторые говорят, что слабая модель предметной области является антишаблоном. 
В действительности это зависит от того, что вы реализуете. Если вы создаете довольно простую микрослужбу  (например, службу CRUD), то слабая модель предметной области не является антишаблоном. Однако если вам предстоит иметь дело со сложной предметной областью микрослужбы, имеющей множество постоянно меняющихся бизнес-правил, слабая модель предметной области может быть антишаблоном для этой микрослужбы или ограниченного контекста.  В этом случае проектирование в соответствии с расширенной моделью предметной области с сущностями,  содержащими данные и поведение, а также с реализацией дополнительных шаблонов DDD (агрегатов, объектов значений и т. п.) может обеспечить огромные преимущества для долгосрочного успешного существования такой микрослужбы.

## Links
https://herbertograca.com/2017/08/17/mvc-and-its-variants
https://habr.com/ru/post/500072/
